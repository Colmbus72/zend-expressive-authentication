{
    "docs": [
        {
            "location": "/",
            "text": "Expressive Authentication Middleware\n\n\n\n\n\n\nzend-expressive-authentication provides middleware for \nExpressive\n\nand \nPSR-7\n applications for the purpose of\nauthenticating HTTP requests using consumer- or third-party-provided adapters.\n\n\nWORK IN PROGRESS\n\n\nThis repository contains a \nwork in progress\n project for building an\nauthentication module for \nExpressive\n and \nPSR-7\n applications.\n\n\nPlease, do not use this code in a production environment!\n\n\nInstallation\n\n\nYou can install the \nzend-expressive-authentication\n library with composer:\n\n\n$ composer require zendframework/zend-expressive-authentication\n\n\n\nDocumentation\n\n\nDocumentation is \nin the doc tree\n, and can be compiled using \nmkdocs\n:\n\n\n$ mkdocs build\n\n\n\nYou may also \nbrowse the documentation online\n.",
            "title": "Expressive Authentication Middleware"
        },
        {
            "location": "/#expressive-authentication-middleware",
            "text": "zend-expressive-authentication provides middleware for  Expressive \nand  PSR-7  applications for the purpose of\nauthenticating HTTP requests using consumer- or third-party-provided adapters.",
            "title": "Expressive Authentication Middleware"
        },
        {
            "location": "/#work-in-progress",
            "text": "This repository contains a  work in progress  project for building an\nauthentication module for  Expressive  and  PSR-7  applications.  Please, do not use this code in a production environment!",
            "title": "WORK IN PROGRESS"
        },
        {
            "location": "/#installation",
            "text": "You can install the  zend-expressive-authentication  library with composer:  $ composer require zendframework/zend-expressive-authentication",
            "title": "Installation"
        },
        {
            "location": "/#documentation",
            "text": "Documentation is  in the doc tree , and can be compiled using  mkdocs :  $ mkdocs build  You may also  browse the documentation online .",
            "title": "Documentation"
        },
        {
            "location": "/v1/intro/",
            "text": "Zend Expressive Authentication\n\n\nThis component provides authentication abstraction using a middleware approach\nfor \nPSR-7\n and\n\nPSR-15\n\napplications.\n\n\nAuthentication is performed using the \nAuthenticationMiddleware\n\nclass. This middleware consumes an \nAuthenticationInterface\n\nadapter to check if a \nPSR-7\n request is\nauthenticated or not. If authenticated, the middleware executes the next\nmiddleware in the application, passing a \nUserInterface\n\nobject via a request attribute. If the request is not authenticated, the\nmiddleware returns a \n401 Unauthorized\n response based on the authentication\nadapter provided.\n\n\nThe \nZend\\Expressive\\Authentication\\UserInterface\n is defined as follows:\n\n\nnamespace Zend\\Expressive\\Authentication;\n\ninterface UserInterface\n{\n    /**\n     * Get the unique user identity (id, username, email address, etc.).\n     */\n    public function getIdentity() : string;\n\n    /**\n     * Get all user roles.\n     *\n     * @return string[]\n     */\n    public function getRoles() : array;\n\n    /**\n     * Get the detail named $name if present; return $default otherwise.\n     */\n    public function getDetail(string $name, $default = null);\n\n    /**\n     * Get all additional user details, if any.\n     */\n    public function getDetails() : array;\n}\n\n\n\nThe \nUserInterface\n attribute in the PSR-7 request can be used for checking\nif a user has been authenticated or not, e.g. it can be used to verify the\nauthorization level of a user (for this scope, it is consumed by\n\nzend-expressive-authorization\n).\n\n\nDefault User class\n\n\nWe provide a default implementation of \nUserInterface\n via the class\n\nZend\\Expressive\\Authentication\\DefaultUser\n. The class is final and immutable,\nin order to prevent runtime changes.\n\n\nRepositories will fetch user information based on the identity, including any\nassociated roles, and optionally any additional details (full name, email,\nprofile information, etc.). Often, user data and the objects representing them\nare unique to the application. As such, the default repository implementations\nwe provide allow you to inject a \nfactory\n for producing the user. This factory\nshould be a PHP callable with the following signature:\n\n\nfunction (string $identity, array $roles = [], array $details = []) : UserInterface\n\n\n\nIn order to notify the package to use your custom factory, you will need to\ncreate a service factory that returns it, and map it to the\n\nZend\\Expressive\\Authentication\\UserInterface\n service.\n\n\nWe provide a service factory named \nZend\\Expressive\\Authentication\\DefaultUserFactory\n\nthat returns a user factory that produces a \nDefaultUser\n instance from the\narguments provided. This is mapped as follows in the service configuration:\n\n\nuse Zend\\Expressive\\Authentication\\DefaultUserFactory;\nuse Zend\\Expressive\\Authentication\\UserInterface;\n\nreturn [\n    // ...\n    'dependencies' => [\n        'factories' => [\n            // ...\n            // Change the DefaultUserFactory::class with your custom service\n            // factory that produces a user factory:\n            UserInterface::class => DefaultUserFactory::class\n        ]\n    ]\n];\n\n\n\nUsage in the route\n\n\nThe \nAuthenticationMiddleware\n can be used to authenticate a route. You just\nneed to add the class name of the middleware in the pipeline of a route.\nAs an example:\n\n\n$app->get('/admin/dashboard', [\n    Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class,\n    Admin\\Action\\Dashboard::class\n], 'admin.dashboard');\n\n\n\nIn this example, the \nAuthenticationMiddleware\n is executed as first middleware\nof the route \nadmin.dashboard\n. If the user is authenticated, the application\nexecutes the \nDashboard\n action; otherwise it returns a \n401 Unauthorized\n\nresponse.\n\n\nChoosing an authentication adapter\n\n\nYou can choose an authentication adapter and a user repository through the\nservice container configuration.\n\n\nYou need to specify the service for authentication using the name\n\nZend\\Expressive\\Authentication\\AuthenticationInterface\n and the user registry\nusing the service name \nZend\\Expressive\\Authentication\\UserRepositoryInterface::class\n.\n\n\nFor instance, using \nzend-servicemanager\n you can easily configure these two\nservices using \naliases\n. Below is an example of configuration using the \nHTTP\nBasic Access Authentication\n adapter and the \nhtpasswd\n file as the user\nrepository.\n\n\nuse Zend\\Expressive\\Authentication\\AuthenticationInterface;\nuse Zend\\Expressive\\Authentication\\Basic;\nuse Zend\\Expressive\\Authentication\\UserRepository;\nuse Zend\\Expressive\\Authentication\\UserRepositoryInterface;\n\nreturn [\n    // ...\n    'dependencies' => [\n        // ...\n        'aliases' => [\n            // ...\n            AuthenticationInterface::class => Basic\\BasicAccess::class,\n            UserRepositoryInterface::class => UserRepository\\Htpasswd::class\n        ]\n    ]\n];",
            "title": "Introduction"
        },
        {
            "location": "/v1/intro/#zend-expressive-authentication",
            "text": "This component provides authentication abstraction using a middleware approach\nfor  PSR-7  and PSR-15 \napplications.  Authentication is performed using the  AuthenticationMiddleware \nclass. This middleware consumes an  AuthenticationInterface \nadapter to check if a  PSR-7  request is\nauthenticated or not. If authenticated, the middleware executes the next\nmiddleware in the application, passing a  UserInterface \nobject via a request attribute. If the request is not authenticated, the\nmiddleware returns a  401 Unauthorized  response based on the authentication\nadapter provided.  The  Zend\\Expressive\\Authentication\\UserInterface  is defined as follows:  namespace Zend\\Expressive\\Authentication;\n\ninterface UserInterface\n{\n    /**\n     * Get the unique user identity (id, username, email address, etc.).\n     */\n    public function getIdentity() : string;\n\n    /**\n     * Get all user roles.\n     *\n     * @return string[]\n     */\n    public function getRoles() : array;\n\n    /**\n     * Get the detail named $name if present; return $default otherwise.\n     */\n    public function getDetail(string $name, $default = null);\n\n    /**\n     * Get all additional user details, if any.\n     */\n    public function getDetails() : array;\n}  The  UserInterface  attribute in the PSR-7 request can be used for checking\nif a user has been authenticated or not, e.g. it can be used to verify the\nauthorization level of a user (for this scope, it is consumed by zend-expressive-authorization ).",
            "title": "Zend Expressive Authentication"
        },
        {
            "location": "/v1/intro/#default-user-class",
            "text": "We provide a default implementation of  UserInterface  via the class Zend\\Expressive\\Authentication\\DefaultUser . The class is final and immutable,\nin order to prevent runtime changes.  Repositories will fetch user information based on the identity, including any\nassociated roles, and optionally any additional details (full name, email,\nprofile information, etc.). Often, user data and the objects representing them\nare unique to the application. As such, the default repository implementations\nwe provide allow you to inject a  factory  for producing the user. This factory\nshould be a PHP callable with the following signature:  function (string $identity, array $roles = [], array $details = []) : UserInterface  In order to notify the package to use your custom factory, you will need to\ncreate a service factory that returns it, and map it to the Zend\\Expressive\\Authentication\\UserInterface  service.  We provide a service factory named  Zend\\Expressive\\Authentication\\DefaultUserFactory \nthat returns a user factory that produces a  DefaultUser  instance from the\narguments provided. This is mapped as follows in the service configuration:  use Zend\\Expressive\\Authentication\\DefaultUserFactory;\nuse Zend\\Expressive\\Authentication\\UserInterface;\n\nreturn [\n    // ...\n    'dependencies' => [\n        'factories' => [\n            // ...\n            // Change the DefaultUserFactory::class with your custom service\n            // factory that produces a user factory:\n            UserInterface::class => DefaultUserFactory::class\n        ]\n    ]\n];",
            "title": "Default User class"
        },
        {
            "location": "/v1/intro/#usage-in-the-route",
            "text": "The  AuthenticationMiddleware  can be used to authenticate a route. You just\nneed to add the class name of the middleware in the pipeline of a route.\nAs an example:  $app->get('/admin/dashboard', [\n    Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class,\n    Admin\\Action\\Dashboard::class\n], 'admin.dashboard');  In this example, the  AuthenticationMiddleware  is executed as first middleware\nof the route  admin.dashboard . If the user is authenticated, the application\nexecutes the  Dashboard  action; otherwise it returns a  401 Unauthorized \nresponse.",
            "title": "Usage in the route"
        },
        {
            "location": "/v1/intro/#choosing-an-authentication-adapter",
            "text": "You can choose an authentication adapter and a user repository through the\nservice container configuration.  You need to specify the service for authentication using the name Zend\\Expressive\\Authentication\\AuthenticationInterface  and the user registry\nusing the service name  Zend\\Expressive\\Authentication\\UserRepositoryInterface::class .  For instance, using  zend-servicemanager  you can easily configure these two\nservices using  aliases . Below is an example of configuration using the  HTTP\nBasic Access Authentication  adapter and the  htpasswd  file as the user\nrepository.  use Zend\\Expressive\\Authentication\\AuthenticationInterface;\nuse Zend\\Expressive\\Authentication\\Basic;\nuse Zend\\Expressive\\Authentication\\UserRepository;\nuse Zend\\Expressive\\Authentication\\UserRepositoryInterface;\n\nreturn [\n    // ...\n    'dependencies' => [\n        // ...\n        'aliases' => [\n            // ...\n            AuthenticationInterface::class => Basic\\BasicAccess::class,\n            UserRepositoryInterface::class => UserRepository\\Htpasswd::class\n        ]\n    ]\n];",
            "title": "Choosing an authentication adapter"
        },
        {
            "location": "/v1/auth-adapter/",
            "text": "Authentication adapters\n\n\nThe authentication adapters for \nzend-expressive-authentication\n implement the\ninterface \nZend\\Expressive\\Authentication\\AuthenticationInterface\n:\n\n\nnamespace Zend\\Expressive\\Authentication;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\ninterface AuthenticationInterface\n{\n    /**\n     * Authenticate the PSR-7 request and return a valid user,\n     * or null if not authenticated\n     *\n     * @param ServerRequestInterface $request\n     * @return UserInterface|null\n     */\n    public function authenticate(ServerRequestInterface $request): ?UserInterface;\n\n    /**\n     * Generate the unauthorized response\n     *\n     * @param ServerRequestInterface $request\n     * @return ResponseInterface\n     */\n    public function unauthorizedResponse(ServerRequestInterface $request): ResponseInterface;\n}\n\n\n\nThis interface contains two method: \nauthenticate()\n to check if a PSR-7\nrequest contains a valid credential, and \nunauthorizedResponse()\n to generate\nand return an unauthorized response.\n\n\nWe provide 4 authentication adapters:\n\n\n\n\nzend-expressive-authentication-basic\n,\n  for \nBasic Access Authentication\n,\n  supporting only \nbcrypt\n as the password hashing algorithm to ensure best\n  security.\n\n\nzend-expressive-authentication-session\n,\n  for authenticating username/password credential pairs and persisting them\n  between requests via PHP sessions.\n\n\nzend-expressive-authentication-zendauthentication\n,\n  supporting the \nzend-authentication\n\n  component.\n\n\nzend-expressive-authentication-oauth2\n,\n  supporting the \nOAuth2\n authentication framework via the\n  \nleague/oauth2-server\n package.",
            "title": "Authentication adapter"
        },
        {
            "location": "/v1/auth-adapter/#authentication-adapters",
            "text": "The authentication adapters for  zend-expressive-authentication  implement the\ninterface  Zend\\Expressive\\Authentication\\AuthenticationInterface :  namespace Zend\\Expressive\\Authentication;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\ninterface AuthenticationInterface\n{\n    /**\n     * Authenticate the PSR-7 request and return a valid user,\n     * or null if not authenticated\n     *\n     * @param ServerRequestInterface $request\n     * @return UserInterface|null\n     */\n    public function authenticate(ServerRequestInterface $request): ?UserInterface;\n\n    /**\n     * Generate the unauthorized response\n     *\n     * @param ServerRequestInterface $request\n     * @return ResponseInterface\n     */\n    public function unauthorizedResponse(ServerRequestInterface $request): ResponseInterface;\n}  This interface contains two method:  authenticate()  to check if a PSR-7\nrequest contains a valid credential, and  unauthorizedResponse()  to generate\nand return an unauthorized response.  We provide 4 authentication adapters:   zend-expressive-authentication-basic ,\n  for  Basic Access Authentication ,\n  supporting only  bcrypt  as the password hashing algorithm to ensure best\n  security.  zend-expressive-authentication-session ,\n  for authenticating username/password credential pairs and persisting them\n  between requests via PHP sessions.  zend-expressive-authentication-zendauthentication ,\n  supporting the  zend-authentication \n  component.  zend-expressive-authentication-oauth2 ,\n  supporting the  OAuth2  authentication framework via the\n   league/oauth2-server  package.",
            "title": "Authentication adapters"
        },
        {
            "location": "/v1/user-repository/",
            "text": "User Repository\n\n\nAn authentication adapter can pull user information from a variety\nof repositories:\n\n\n\n\nan \nhtpasswd\n file\n\n\na database\n\n\na cache\n\n\n\n\nzend-expressive-authentication provides an interface,\n\nZend\\Expressive\\Authentication\\UserRepositoryInterface\n, to access this user\nstorage:\n\n\nnamespace Zend\\Expressive\\Authentication;\n\ninterface UserRepositoryInterface\n{\n    /**\n     * Authenticate the credential (username) using a password\n     * or using only the credential string (e.g. token based credential)\n     * It returns the authenticated user or null.\n     *\n     * @param string $credential can be also a token\n     */\n    public function authenticate(string $credential, string $password = null) : ?UserInterface;\n}\n\n\n\nIt contains only the \nauthenticate()\n function, to authenticate the user's\ncredential. If authenticated, the result will be a \nUserInterface\n instance;\notherwise, a \nnull\n value is returned.\n\n\nConfigure the user repository\n\n\nIn order to use a user repository adapter, we need to configure it. For instance,\nto consume an \nhtpasswd\n file, we need to configure the path to the file.\nSuch configuration is provided in the \nauthentication\n hierarchy provided to\nyour \nPSR-11\n container. We demonstrate\nexamples of such configuration below.\n\n\nUsing \nExpressive\n, this\nconfiguration can be stored in a file under the \n/config/autoload/\n folder.  We\nsuggest to use a \n.local.php\n suffix \u2014 e.g.\n\n/config/autoload/auth.local.php\n \u2014 as local configuration is not stored\nin the version control system.\n\n\nYou can also provide this configuration using a \nConfigProvider.php\n\nclass. \nRead this blog post\n\nfor more information on config providers.\n\n\nhtpasswd configuration\n\n\nWhen using the htpasswd user repository implementation, you need only configure\nthe path to the \nhtpasswd\n file:\n\n\nreturn [\n    'authentication' => [\n        'htpasswd' => 'insert the path to htpasswd file',\n    ],\n];\n\n\n\nPDO configuration\n\n\nWhen using the PDO user repository adapter, you will need to provide PDO\nconnection parameters, as well as information on the table, field names, and a\nSQL statement for retrieiving user roles:\n\n\nreturn [\n    'authentication' => [\n        'pdo' => [\n            'dsn' => '',\n            'username' => '',\n            'password' => '',\n            'table' => 'user table name',\n            'field' => [\n                'identity' => 'identity field name',\n                'password' => 'password field name',\n            ],\n            'sql_get_roles'   => 'SQL to retrieve roles with :identity parameter',\n            'sql_get_details' => 'SQL to retrieve user details by :identity',\n        ],\n    ],\n];\n\n\n\nThe required parameters are \ndsn\n, \ntable\n, and \nfield\n.\n\n\nThe \ndsn\n value is the DSN connection string to be used to connect to the database.\nFor instance, using a SQLite database, a typical value is \nsqlite:/path/to/file\n.\n\n\nThe \nusername\n and \npassword\n parameters are optional parameters used to connect\nto the database. Depending on the database, these parameters may not be required;\ne.g. \nSQLite\n does not require them.\n\n\nThe \ntable\n value is the name of the table containing the user credentials.\n\n\nThe \nfield\n parameter contains the field name of the \nidentity\n of the user and\nthe user \npassword.\n The \nidentity\n of the user can be a username, an email, etc.\n\n\nThe \nsql_get_roles\n setting is an optional parameter that contains the SQL query\nfor retrieving the user roles. The identity value must be specified using the\nplaceholder \n:identity\n. For instance, if a role is stored in a user table, a\ntypical query might look like the following:\n\n\nSELECT role FROM user WHERE username = :identity\n\n\n\nThe \nsql_get_details\n parameter is similar to \nsql_get_roles\n: it specifies the\nSQL query for retrieving the user's additional details, if any.\n\n\nFor instance, if a user has an email field this can be returned as additional\ndetail using the following query:\n\n\nSELECT email FROM user WHERE username = :identity",
            "title": "User repository"
        },
        {
            "location": "/v1/user-repository/#user-repository",
            "text": "An authentication adapter can pull user information from a variety\nof repositories:   an  htpasswd  file  a database  a cache   zend-expressive-authentication provides an interface, Zend\\Expressive\\Authentication\\UserRepositoryInterface , to access this user\nstorage:  namespace Zend\\Expressive\\Authentication;\n\ninterface UserRepositoryInterface\n{\n    /**\n     * Authenticate the credential (username) using a password\n     * or using only the credential string (e.g. token based credential)\n     * It returns the authenticated user or null.\n     *\n     * @param string $credential can be also a token\n     */\n    public function authenticate(string $credential, string $password = null) : ?UserInterface;\n}  It contains only the  authenticate()  function, to authenticate the user's\ncredential. If authenticated, the result will be a  UserInterface  instance;\notherwise, a  null  value is returned.",
            "title": "User Repository"
        },
        {
            "location": "/v1/user-repository/#configure-the-user-repository",
            "text": "In order to use a user repository adapter, we need to configure it. For instance,\nto consume an  htpasswd  file, we need to configure the path to the file.\nSuch configuration is provided in the  authentication  hierarchy provided to\nyour  PSR-11  container. We demonstrate\nexamples of such configuration below.  Using  Expressive , this\nconfiguration can be stored in a file under the  /config/autoload/  folder.  We\nsuggest to use a  .local.php  suffix \u2014 e.g. /config/autoload/auth.local.php  \u2014 as local configuration is not stored\nin the version control system.  You can also provide this configuration using a  ConfigProvider.php \nclass.  Read this blog post \nfor more information on config providers.",
            "title": "Configure the user repository"
        },
        {
            "location": "/v1/user-repository/#htpasswd-configuration",
            "text": "When using the htpasswd user repository implementation, you need only configure\nthe path to the  htpasswd  file:  return [\n    'authentication' => [\n        'htpasswd' => 'insert the path to htpasswd file',\n    ],\n];",
            "title": "htpasswd configuration"
        },
        {
            "location": "/v1/user-repository/#pdo-configuration",
            "text": "When using the PDO user repository adapter, you will need to provide PDO\nconnection parameters, as well as information on the table, field names, and a\nSQL statement for retrieiving user roles:  return [\n    'authentication' => [\n        'pdo' => [\n            'dsn' => '',\n            'username' => '',\n            'password' => '',\n            'table' => 'user table name',\n            'field' => [\n                'identity' => 'identity field name',\n                'password' => 'password field name',\n            ],\n            'sql_get_roles'   => 'SQL to retrieve roles with :identity parameter',\n            'sql_get_details' => 'SQL to retrieve user details by :identity',\n        ],\n    ],\n];  The required parameters are  dsn ,  table , and  field .  The  dsn  value is the DSN connection string to be used to connect to the database.\nFor instance, using a SQLite database, a typical value is  sqlite:/path/to/file .  The  username  and  password  parameters are optional parameters used to connect\nto the database. Depending on the database, these parameters may not be required;\ne.g.  SQLite  does not require them.  The  table  value is the name of the table containing the user credentials.  The  field  parameter contains the field name of the  identity  of the user and\nthe user  password.  The  identity  of the user can be a username, an email, etc.  The  sql_get_roles  setting is an optional parameter that contains the SQL query\nfor retrieving the user roles. The identity value must be specified using the\nplaceholder  :identity . For instance, if a role is stored in a user table, a\ntypical query might look like the following:  SELECT role FROM user WHERE username = :identity  The  sql_get_details  parameter is similar to  sql_get_roles : it specifies the\nSQL query for retrieving the user's additional details, if any.  For instance, if a user has an email field this can be returned as additional\ndetail using the following query:  SELECT email FROM user WHERE username = :identity",
            "title": "PDO configuration"
        }
    ]
}